1.C++引用折叠规则：
只要有左值引用参与，则结果为左值引用。
否则，结果为右值引用。

2.内存对齐：

内存对齐规则
每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

3.Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，
从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性。

ASLR 机制会对以下三个部分进行随机化：

Random stack offset：Linux 会在进程启动时将栈顶地址随机化，从而防止攻击者通过栈溢出攻击获取程序控制权。
Random mmap offset：Linux 会对每个内存映射段的起始地址进行随机化，从而防止攻击者获取内存映射段的地址，进而执行代码注入等攻击。
Random brk offset：Linux 会对堆的起始地址进行随机化，从而防止攻击者通过堆溢出攻击获取程序控制权。

4.C++类的构造函数执行顺序：
ps：不管是直接还是间接继承了虚基类，只要虚基类不是只有默认的无参构造函数，就需要在初始化列表中对它进行初始化

执行顺序：
1.如果该类有直接或者间接的虚基类，则先执行虚基类的构造函数。
2.如果该类还有其他基类，则按照它们在继承声明列表中出现的次序，分别执行它们的构造函数，但构造过程中，不再执行它们的虚基类构造函数。
3.按照在类定义中出现的次序，对派生类中新增的成员对象进行初始化。对类类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定参数
执行构造函数，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋初值。
否则什么也不做。
4.执行自己构造函数的函数体。

5.为何中文最好使用宽字符。
在string类型中，其实际上是 typedef basic_string<char> string;
处理的基本单元为一个字节。对于一个中文字符，通常占两个字节。这是用两个char表示的，就会带来一些问题。

string s = "这是一个中文字符串"
1.s.size()的结果是18，这就很不符合常识。
2.这种表示方式，一个汉字的第二个字节和下一个汉字的第一个字节仍然能构成汉字。
比如在GBK编码下，s.substr(3,2)的结果为 “且”
3.s.find("且")，也能够返回3,（实际上并不存在这个字）。

所以最好使用宽字符，wchar_t，一个宽字符占两个字节。
使用对应的宽流输出wcout,wistream,wifstream,wistringstream...（实际上是模板参数<char>换成了<wchar_t>）

6.无论是采用二进制输出还是文本文件输出，其输出到磁盘的结果本质都是二进制格式，只是文本文件输出，在windows下，每输出一个'\n'，都会自作聪明的添加一个'\r'

7.
template<typename... Args>
void show_list3(Args... args) 

Args为模板参数包
args为函数参数包
1.递归展开（不推荐）
2.非递归展开（要用到C++17折叠表达式）

8.C++11引用折叠规则：只要有左值引用参与折叠，折叠后就是左值引用。

9.折叠表达式是C++17新引进的语法特性。使用折叠表达式可以简化对C++11中引入的参数包的处理，从而在某些情况下避免使用递归。折叠表达式共有四种语法形式。分别为一元的左折叠和右折叠，以及二元的左折叠和右折叠。

1、一元右折叠(unary right fold)
( pack op ... )
一元右折叠(E op ...)展开之后变为 E1 op (... op (EN-1 op EN))
2、一元左折叠(unary left fold)
( ... op pack )
一元左折叠(... op E)展开之后变为 ((E1 op E2) op ...) op EN
3、二元右折叠(binary right fold)
( pack op ... op init )
二元右折叠(E op ... op I)展开之后变为 E1 op (... op (EN−1 op (EN op I)))
4、二元左折叠(binary left fold)
( init op ... op pack )
二元左折叠(I op ... op E)展开之后变为 (((I op E1) op E2) op ...) op EN

op代表运算符，在二元折叠中，两个运算符必须相同。

pack代表参数包

init代表初始值

省略号在包的左边就是左折叠
省略号在包的右边就是右折叠

10.
decltype推导规则
decltype(e)（其中e的类型为T）的推导规则有5条：

如果e是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。
如果e是一个函数调用或者仿函数调用(或者表达式），那么decltype(e)推断出的类型是其返回值的类型。
如果e是一个类型为T的左值，则decltype(e)是T&。cv操作符将被保留。
如果e是一个类型为T的将亡值，则decltype(e)是T&&。
除去以上情况，则decltype(e)是T
11.
如果要让数组不衰退成指针类型的话，
现在提倡
template <typename T>
void fun( T& x ) { ... } (也能推断出数组大小)

template <typename T, size_t N>
void fun( T (&x)[N] ) { ... } 
这种写法在"effective modern c++"中已经提到，是多余的。

12.
T&&是万能引用，const T&&不是
const T&&允许你重载一个函数模板，它只接受右值引用。
如果const T&&也被当做universal reference，那么将没有办法让函数只接受右值引用。

13.
在函数声明后面加上&符号，表示该方法只能被左值对象调用
在函数声明后面加上&&符号，表示该方法只能被右值对象调用
struct foo
{
    int i = 42;
    int  get() && { return i; }
    int& get() &  { return i; }
};
14.在《Effective Modern C++》中建议：对于右值引用使用std::move，对于万能引用使用std::forward。

{
    15.
    简单理解，
    xvalue就是和右值引用相关的值。
    prvalue就是不和右值引用相关的，纯右值，也叫临时对象。

    【纯右值 prvalue】
    是没有标识符、不可以取地址的表达式，一般也称之为“临时对 象”。最常见的情况有：

    1.返回非引用类型的表达式、函数调用

    2.如 x++、x + 1

    3.除字符串字面量之外的字面量如 42、true


    【将亡值 xvalue】

    1.隐式或显式调用函数的结果，该函数的返回类型是对所返回对象类型的右值引用
    int&& f(){
        return 3;
    }

    2.对对象类型右值引用的转换
    static_cast<int&&>(7); 
    std::move(7);

    3.类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue
    struct As
    {
        int i;
    };

    As&& f(){
        return As();
    }

    int main()
    {
        f().i; 
        return 0;
    }


}

{
    16.NRVO.cpp
    在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），
    能把对象直接构造到调用者的栈上。
    从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，
    而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。 
}

{
    17.
    constexpr函数
    constexpr也可以用于函数。一个constexpr函数是在编译时计算其结果的函数。这意味着函数的所有参数都必须是常量表达式，
    并且函数体中不能有任何会改变状态的语句（例如，赋值语句或递增/递减操作）。
    constexpr int square(int number) {
        return number * number;
    }

    constexpr int x = square(10);  // 这是合法的，因为square是一个constexpr函数

}

{
什么是GOT表
GOT（Global Offset Table）是一个全局偏移表，用于动态链接的过程中解决全局符号的地址引用。[它是在可执行文件或共享库加载到内存时由动态链接器填充的数据结构]。

程序A引用了动态库中定义的某个全局变量，需要知道其地址，但这个地址又无法在编译链接时确定，因为动态库是运行时期加载的，其地址在运行时期才能确定(实际上还可以编译时链接，此处仅考虑运行时链接这种情况），
那链接器如何解决该问题？


动态链接过程中的重定位并不像静态链接那样方便，对于静态链接而言，[重定位过程可以直接修改指令中对数据的引用地址，因为静态链接操作的是 elf 文件]，
[而动态链接则做不到，因为这时候指令已经被加载到内存中，且映射为[只读]属性]。

有些朋友就有疑问了，为什么要强行把代码段的数据映射为只读属性，映射成读写属性不行吗，这样动态链接过程就可以直接修改指令了，实际上还真不行。
一方面，映射为只读属性是出于保护代码不被修改的目的.
另一方面，如果动态库 A 引用了动态库 B，在重定位过程中修改了动态库 A 中的指令部分，但是，动态库是进程之间共享的，某一个进程修改动态库会导致其它进程的引用出错。

那么问题来了，如果不能修改指令，那怎么完成重定位过程？毕竟指令中编码的地址是不能直接使用的。答案是通过数据部分进行一次跳转。

对于所有的进程而言，动态库的数据部分是有独立的一份副本的，这也很好理解，程序的数据部分是读写属性的，对数据的操作由进程说了算，
所以，在重定位过程中，既然不能修改代码部分，那么我们只能通过修改数据部分来完成重定位的过程。

这种实现的机制使用了 GOT 表，全名为 global offset table，即全局偏移表。在执行的指令中，本来需要引用符号 A ，但是 A 存在于动态库中，
链接过程并不知道它的地址，于是将 A 的地址部分改写为 GOT 表中某一项数据，在编译阶段 GOT 表中是没有真实数据的，但是在动态链接的加载阶段，
动态链接器就可以将符号 A 的真实地址填写到 GOT 表中对应的数据项中，这样指令对 A 就产生了正确的引用。

PS: 增加代理（跳板）是计算机常用的解决问题的手段。

GOT 中每一个表项占用 4 个字节(32位)，表示运行时的符号的真实地址。

对于函数而言，可以在加载阶段通过 GOT 表获取到函数的地址保存到寄存器中，然后跳转到该地址，同样可以实现加载时的重定位，但是在实际的指令重定位中，并不单单使用 GOT 表，还使用了另一个 PLT 表实现。

GOT 表是针对外部符号引用的，而 PLT 针对外部跳转引用，通常就是函数跳转。

当一个程序需要访问一个全局变量或调用一个外部函数时，编译器无法确定真正的地址，因为这些全局符号的地址是在程序运行时才被分配的。
为了解决这个问题，编译器将所有涉及全局符号的引用替换成对GOT的间接引用。

GOT是一个特殊的数据段，存储着全局符号的地址。它是一个数组，每个元素对应一个全局符号的地址。
在程序启动时，动态链接器会填充GOT中的每个元素，将真正的地址写入其中。这样，当程序需要访问一个全局变量，它实际上是通过间接引用GOT中的对应元素来获取地址。

GOT的目的是提供一种机制，使得程序中的地址引用可以在动态链接的情况下解决。通过使用GOT，编译器和链接器可以将地址引用的解析延迟到程序运行时，从而支持动态加载和共享库的使用。
}