#include <cmath>  // 用于sqrt函数
#include <gtest/gtest.h>

bool IsPrime(int n)
{
    if (n <= 1)
        return false;  // 0和1不是质数
    if (n <= 3)
        return true;  // 2和3是质数
    if (n % 2 == 0 || n % 3 == 0)
        return false;  // 排除能被2或3整除的数
    for (int i = 5; i <= std::sqrt(n); i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    return true;
}
TEST(Algorithms, IsPrime){}
/*
关键点解析：
1.	只检查到 sqrt(n)：
	如果一个数 n 是合数（非质数），必然可以分解为两个因子的乘积，例如 n=a×b，其中 a≤b
	因此，较小的因子一定小于等于 sqrt{n}，无需检查更大的值。

2.	跳过不可能的因子：
	除了 2 和 3，质数只能是 6k±1的形式。
	质数在 6 的倍数两侧分布，比如：5、7 是 6 的倍数左右。
	任何 n 如果不能被 2 和 3 整除，所有潜在因子也必须是 6k±1。
	优化： 使用 i += 6 跳跃式遍历，将循环效率提高。

3.	检查 i 和 i+2：
	遍历到的 i 是候选因子（6k−1），而 i+2是对应的6k+1。
	如果 n%i==0 或 n%(i+2)==0，说明 n 不是质数。

质数除了2和3以外，只可能是6K+-1的形式。这背后的原因源于数学中的模运算规律，下面详细说明：

1. 模6的性质：

一个整数n可以表示为：

n = 6k, 6k+1, 6k+2, 6k+3, 6k+4, 6k+5

2. 排除非质数的情况：

根据定义，质数只能被1和自身整除。所以，以下几种情况可以直接排除：

6k：显然是6的倍数，且n>6时不是质数。

6K+2：是2的倍数（偶数），不是质数。

6k+3：是3的倍数，且n>3时不是质数。

6k+4：是2的倍数，也不是质数。


3. 剩下的可能性：

经过排除，只有以下两种情况：

6k+1
6k+5，即6k-1 


因此，所有大于3的质数只能是6k+-1的形式。    
*/
