1.网络号为127（01111111）保留作为本地软件环回测试本主机的进程之间的通信之用。若一个主机发送一个目的地址为环回地址（如127.0.0.1）的IP数据报，
则本主机中的协议软件就会处理数据报中的数据，而不会把数据报发送到任何网络。  
2.
网络号|主机号|源地址使用|目的地址使用|代表的意思
|:---:|:---:|:----:|:----:|:-----:|
0|0|可以|不可以|在本网络上的本主机
0|host-id|可以|不可以|在本网络上的某台主机host-id
全1|全1|不可以|可以|只在本网络上进行广播（各路由器均不转发）
net-id|全1|不可|可以|对net-id上的所有主机进行广播
127|非全0或全1的任何数|可以|可以|用于本地软件环回测试
net-id|全0|不可以|可以|网络地址

3.ARP高速缓存。ARP是解决同一局域网上的主机或者路由器的IP地址和硬件地址的映射问题。

4.Nagle算法，全称为John Nagle提出的Nagle算法，是一种用于减少网络传输中的小包数量，从而提高网络效率的算法。它主要应用于TCP协议中。Nagle算法的基本原理是：当一个TCP连接上有数据要发送时，并不立即发送出去，而是等待一小段时间（通常是由一个RTT，即往返时延来估计），看看是否有更多的数据要发送。如果在这段时间内有额外的数据产生，那么这些数据就会被组装成一个更大的报文一起发送。这样做可以减少网络中由于过多的小包而引起的拥塞。

Nagle算法的核心规则如下：
1. **如果当前有一个部分填写的报文段（即还有可用空间可添加数据）在等待发送，那么就等到这个报文段填满或者达到最大延迟时间后再发送。**
2. **对于包含ACK（确认应答）但不携带数据的报文段，可以立即发送，不受上述规则限制。这是为了快速响应对方，避免延迟ACK导致的拥塞窗口增长停滞。**
3. **如果发生了超时或者收到了三个重复的ACK（这通常意味着网络拥塞或数据包丢失），则立即发送一个报文段，即使它没有填满。**

Nagle算法的优点在于减少了网络中的数据包数量，降低了网络拥塞的可能性，提高了网络的整体吞吐量。然而，它也可能引入额外的延迟，特别是在交互式应用中，如Telnet或SSH，用户可能感觉到响应变慢。为此，TCP协议提供了TCP_NODELAY选项，允许应用程序禁用Nagle算法，以牺牲带宽效率为代价，换取更低的延迟。

5.一致性哈希算法是1997年在论文Consistenthashingandrandomtrees中被提出 [3]，在分布式系统中应用非常广泛。一致性哈希是一种哈希算法，简单地说在移除或者添加一个服务器时，此算法能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系，尽可能满足单调性的要求。在普通分布式集群中，服务请求与处理请求服务器之间可以一一对应，也就是说固定服务请求与处理服务器之间的映射关系，某个请求由固定的服务器去处理。这种方式无法对整个系统进行负载均衡，可能会造成某些服务器过于繁忙以至于无法处理新来的请求。而另一些服务器则过于空闲，整体系统的资源利用率低，并且当分布式集群中的某个服务器宕机，会直接导致某些服务请求无法处理 [4]。
进一步的改进可以利用hash算法对服务请求与处理服务器之间的关系进行映射，以达到动态分配的目的。通过hash算法对服务请求进行转换，转换后的结果对服务器节点值进行取模运算，取模后的值就是服务请求对应的请求处理服务器。这种方法可以应对节点失效的情况，当某个分布式集群节点宕机，服务请求可以通过hash算法重新分配到其他可用的服务器上(因为是取模运算，增加或删除服务器会导致模数发生改变，所以取模结果也会发生改变)。避免了无法处理请求的状况出现 [4]。
但这种方法的缺陷也很明显，如果服务器中保存有服务请求对应的数据，那么如果重新计算请求的hash值，会造成大量的请求被重定位到不同的服务器而造成请求所要使用的数据失效，这种情况在分布式系统中是非常糟糕的。一个设计良好的分布式系统应该具有良好的单调性，即服务器的添加与移除不会造成大量的哈希重定位，而一致性哈希恰好可以解决这个问题 [4]。
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0~232-1。整个空间按顺时针方向组织。0~232-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性 [4]。

6.SO_REUSEADDR SO_REUSEPORT https://www.cnblogs.com/schips/p/12553321.html

SO_REUSEADDR 主要改变了系统对待通配符IP地址冲突的方式。
只要我们对新的socket设置了SO_REUSEADDR就成立。至于原有的已经绑定在当前地址端口对上的，处于或不处于TIME_WAIT阶段的socket是否设置了SO_REUSEADDR并无影响。
决定bind操作是否成功的代码仅仅会检查新的被传递到bind()方法的socket的SO_REUSEADDR选项。其他涉及到的socket的SO_REUSEADDR选项并不会被检查。

SO_REUSEPORT 允许我们将任意数目的socket绑定到完全相同的源地址:端口对上
需要所有之前绑定的socket都设置了SO_REUSEPORT选项
与SO_REUSEADDR不同的是 ，处理SO_REUSEPORT的代码不仅会检查当前尝试绑定的socket的SO_REUSEPORT，而且也会检查之前已绑定了当前尝试绑定的地址端口对的socket的SO_REUSEPORT选项

7.Connect()返回EADDRINUSE？（能同时绑定，但是不能同时建立连接...）

有些时候bind()操作会返回EADDRINUSE错误。但奇怪的是，在我们调用connect()操作时，也有可能得到EADDRINUSE错误。这是为什么呢？为何一个我们尝试令当前端口建立连接的远程地址也会被占用呢？难道将多个socket连接到同一个远程地址的操作会有什么问题产生吗？

正如本文之前所说，一个连接关系是由一个五元组确定的。对于任意的连接关系而言，这个五元组必须是唯一的。否则的话，系统将无法分辨两个连接。而现在当我们采用了地址复用之后，我们可以将两个采用相同协议的socket绑定到同一地址端口对上。这意味着对这两个socket而言，五元组里的{, , }已经相同了。在这种情况下，如果我们尝试将它们都连接到同一个远程地址端口上，这两个连接关系的五元组将完全相同。也就是说，产生了两个完全相同的连接。在TCP协议中这是不被允许的（UDP是无连接的）。如果这两个完全相同的连接种的某一个接收到了数据，系统将无法分辨这个数据到底属于哪个连接。所以在这种情况下，至少这两个socket所尝试连接的远程主机的地址和端口不能相同。只有如此，系统才能继续区分这两个连接关系。

所以当我们将两个采用相同协议的socket绑定到同一个本地地址端口对上后，如果我们还尝试让它们和同一个目的地址端口对建立连接，第二个尝试调用connect()方法的socket将会报EADDRINUSE的错误，这说明一个拥有完全相同的五元组的socket已经存在了。

8.int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
sockfd：标识一个套接口的描述字。
level：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。
optname：需设置的选项。
optval：指针，指向存放选项待设置的新值的缓冲区。
optlen：optval缓冲区长度。
linux内核中定义为：
static int setsockopt(struct socket *sock,int lvl, int opt, char __user *ov, unsigned int ol);

有两种套接口的选项：一种是布尔型选项，允许或禁止一种特性；另一种是整型或结构选项。允许一个布尔型选项，则将optval指向非零整形数；禁止一个选项optval指向一个等于零的整形数。对于布尔型选项，optlen应等于sizeof(int)；对其他选项，optval指向包含所需选项的整形数或结构，而optlen则为整形数或结构的长度。SO_LINGER选项用于控制下述情况的行动：套接口上有排队的待发送数据，且closesocket()调用已执行。参见closesocket()函数中关于SO_LINGER选项对closesocket()语义的影响。

9.SO_REUSEADDR 更常用于快速重启服务，允许一个程序在端口仍处于使用状态时重新绑定。
SO_REUSEPORT 主要用于提高性能，允许多个进程或线程共享同一端口以处理并发连接。

10.关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭。

如果进程异常退出了，内核就会发送 RST 报文来关闭，它可以不走四次挥手流程，是一个暴力关闭连接的方式。

安全关闭连接的方式必须通过四次挥手，它由进程调用 close 和 shutdown 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。

调用 close 函数和 shutdown 函数有什么区别？
调用了 close 函数意味着完全断开连接，完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。

使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 shutdown 函数，它可以控制只关闭一个方向的连接：

int shutdown(int sock, int howto);
第二个参数决定断开连接的方式，主要有以下三种方式：

SHUT_RD(0)：关闭连接的「读」这个方向，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了
SHUT_WR(1)：关闭连接的「写」这个方向，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。
SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向。