1.C++引用折叠规则：
只要有左值引用参与，则结果为左值引用。
否则，结果为右值引用。

2.内存对齐：

内存对齐规则
每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

3.Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，
从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性。

ASLR 机制会对以下三个部分进行随机化：

Random stack offset：Linux 会在进程启动时将栈顶地址随机化，从而防止攻击者通过栈溢出攻击获取程序控制权。
Random mmap offset：Linux 会对每个内存映射段的起始地址进行随机化，从而防止攻击者获取内存映射段的地址，进而执行代码注入等攻击。
Random brk offset：Linux 会对堆的起始地址进行随机化，从而防止攻击者通过堆溢出攻击获取程序控制权。

4.C++类的构造函数执行顺序：
ps：不管是直接还是间接继承了虚基类，只要虚基类不是只有默认的无参构造函数，就需要在初始化列表中对它进行初始化

执行顺序：
1.如果该类有直接或者间接的虚基类，则先执行虚基类的构造函数。
2.如果该类还有其他基类，则按照它们在继承声明列表中出现的次序，分别执行它们的构造函数，但构造过程中，不再执行它们的虚基类构造函数。
3.按照在类定义中出现的次序，对派生类中新增的成员对象进行初始化。对类类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定参数
执行构造函数，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋初值。
否则什么也不做。
4.执行自己构造函数的函数体。

5.为何中文最好使用宽字符。
在string类型中，其实际上是 typedef basic_string<char> string;
处理的基本单元为一个字节。对于一个中文字符，通常占两个字节。这是用两个char表示的，就会带来一些问题。

string s = "这是一个中文字符串"
1.s.size()的结果是18，这就很不符合常识。
2.这种表示方式，一个汉字的第二个字节和下一个汉字的第一个字节仍然能构成汉字。
比如在GBK编码下，s.substr(3,2)的结果为 “且”
3.s.find("且")，也能够返回3,（实际上并不存在这个字）。

所以最好使用宽字符，wchar_t，一个宽字符占两个字节。
使用对应的宽流输出wcout,wistream,wifstream,wistringstream...（实际上是模板参数<char>换成了<wchar_t>）

6.无论是采用二进制输出还是文本文件输出，其输出到磁盘的结果本质都是二进制格式，只是文本文件输出，在windows下，每输出一个'\n'，都会自作聪明的添加一个'\r'

7.
template<typename... Args>
void show_list3(Args... args) 

Args为模板参数包
args为函数参数包
1.递归展开（不推荐）
2.非递归展开（要用到C++17折叠表达式）

8.C++11引用折叠规则：只要有左值引用参与折叠，折叠后就是左值引用。

9.折叠表达式是C++17新引进的语法特性。使用折叠表达式可以简化对C++11中引入的参数包的处理，从而在某些情况下避免使用递归。折叠表达式共有四种语法形式。分别为一元的左折叠和右折叠，以及二元的左折叠和右折叠。

1、一元右折叠(unary right fold)
( pack op ... )
一元右折叠(E op ...)展开之后变为 E1 op (... op (EN-1 op EN))
2、一元左折叠(unary left fold)
( ... op pack )
一元左折叠(... op E)展开之后变为 ((E1 op E2) op ...) op EN
3、二元右折叠(binary right fold)
( pack op ... op init )
二元右折叠(E op ... op I)展开之后变为 E1 op (... op (EN−1 op (EN op I)))
4、二元左折叠(binary left fold)
( init op ... op pack )
二元左折叠(I op ... op E)展开之后变为 (((I op E1) op E2) op ...) op EN

op代表运算符，在二元折叠中，两个运算符必须相同。

pack代表参数包

init代表初始值

省略号在包的左边就是左折叠
省略号在包的右边就是右折叠

10.
decltype推导规则
decltype(e)（其中e的类型为T）的推导规则有5条：

如果e是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。
如果e是一个函数调用或者仿函数调用(或者表达式），那么decltype(e)推断出的类型是其返回值的类型。
如果e是一个类型为T的左值，则decltype(e)是T&。cv操作符将被保留。
如果e是一个类型为T的将亡值，则decltype(e)是T&&。
除去以上情况，则decltype(e)是T
11.
如果要让数组不衰退成指针类型的话，
现在提倡
template <typename T>
void fun( T& x ) { ... } (也能推断出数组大小)

template <typename T, size_t N>
void fun( T (&x)[N] ) { ... } 
这种写法在"effective modern c++"中已经提到，是多余的。

12.
T&&是万能引用，const T&&不是
const T&&允许你重载一个函数模板，它只接受右值引用。
如果const T&&也被当做universal reference，那么将没有办法让函数只接受右值引用。

13.
在函数声明后面加上&符号，表示该方法只能被左值对象调用
在函数声明后面加上&&符号，表示该方法只能被右值对象调用
struct foo
{
    int i = 42;
    int  get() && { return i; }
    int& get() &  { return i; }
};
14.在《Effective Modern C++》中建议：对于右值引用使用std::move，对于万能引用使用std::forward。

{
    15.
    简单理解，
    xvalue就是和右值引用相关的值。
    prvalue就是不和右值引用相关的，纯右值，也叫临时对象。

    【纯右值 prvalue】
    是没有标识符、不可以取地址的表达式，一般也称之为“临时对 象”。最常见的情况有：

    1.返回非引用类型的表达式、函数调用

    2.如 x++、x + 1

    3.除字符串字面量之外的字面量如 42、true


    【将亡值 xvalue】

    1.隐式或显式调用函数的结果，该函数的返回类型是对所返回对象类型的右值引用
    int&& f(){
        return 3;
    }

    2.对对象类型右值引用的转换
    static_cast<int&&>(7); 
    std::move(7);

    3.类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue
    struct As
    {
        int i;
    };

    As&& f(){
        return As();
    }

    int main()
    {
        f().i; 
        return 0;
    }


}

{
    16.NRVO.cpp
    在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），
    能把对象直接构造到调用者的栈上。
    从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，
    而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。 
}

{
    constexpr函数
    constexpr也可以用于函数。一个constexpr函数是在编译时计算其结果的函数。这意味着函数的所有参数都必须是常量表达式，
    并且函数体中不能有任何会改变状态的语句（例如，赋值语句或递增/递减操作）。
    constexpr int square(int number) {
        return number * number;
    }

    constexpr int x = square(10);  // 这是合法的，因为square是一个constexpr函数

}