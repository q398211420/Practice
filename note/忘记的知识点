1.C++引用折叠规则：
只要有左值引用参与，则结果为左值引用。
否则，结果为右值引用。

2.内存对齐：

内存对齐规则
每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

3.Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，
从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性。

ASLR 机制会对以下三个部分进行随机化：

Random stack offset：Linux 会在进程启动时将栈顶地址随机化，从而防止攻击者通过栈溢出攻击获取程序控制权。
Random mmap offset：Linux 会对每个内存映射段的起始地址进行随机化，从而防止攻击者获取内存映射段的地址，进而执行代码注入等攻击。
Random brk offset：Linux 会对堆的起始地址进行随机化，从而防止攻击者通过堆溢出攻击获取程序控制权。

4.C++类的构造函数执行顺序：
ps：不管是直接还是间接继承了虚基类，只要虚基类不是只有默认的无参构造函数，就需要在初始化列表中对它进行初始化

执行顺序：
1.如果该类有直接或者间接的虚基类，则先执行虚基类的构造函数。
2.如果该类还有其他基类，则按照它们在继承声明列表中出现的次序，分别执行它们的构造函数，但构造过程中，不再执行它们的虚基类构造函数。
3.按照在类定义中出现的次序，对派生类中新增的成员对象进行初始化。对类类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定参数
执行构造函数，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋初值。
否则什么也不做。
4.执行自己构造函数的函数体。

5.为何中文最好使用宽字符。
在string类型中，其实际上是 typedef basic_string<char> string;
处理的基本单元为一个字节。对于一个中文字符，通常占两个字节。这是用两个char表示的，就会带来一些问题。

string s = "这是一个中文字符串"
1.s.size()的结果是18，这就很不符合常识。
2.这种表示方式，一个汉字的第二个字节和下一个汉字的第一个字节仍然能构成汉字。
比如在GBK编码下，s.substr(3,2)的结果为 “且”
3.s.find("且")，也能够返回3,（实际上并不存在这个字）。

所以最好使用宽字符，wchar_t，一个宽字符占两个字节。
使用对应的宽流输出wcout,wistream,wifstream,wistringstream...（实际上是模板参数<char>换成了<wchar_t>）

6.无论是采用二进制输出还是文本文件输出，其输出到磁盘的结果本质都是二进制格式，只是文本文件输出，在windows下，每输出一个'\n'，都会自作聪明的添加一个'\r'

7.
template<typename... Args>
void show_list3(Args... args) 

Args为模板参数包
args为函数参数包
1.递归展开（不推荐）
2.非递归展开（要用到C++17折叠表达式）

8.C++11引用折叠规则：只要有左值引用参与折叠，折叠后就是左值引用。

9.折叠表达式是C++17新引进的语法特性。使用折叠表达式可以简化对C++11中引入的参数包的处理，从而在某些情况下避免使用递归。折叠表达式共有四种语法形式。分别为一元的左折叠和右折叠，以及二元的左折叠和右折叠。

1、一元右折叠(unary right fold)
( pack op ... )
一元右折叠(E op ...)展开之后变为 E1 op (... op (EN-1 op EN))
2、一元左折叠(unary left fold)
( ... op pack )
一元左折叠(... op E)展开之后变为 ((E1 op E2) op ...) op EN
3、二元右折叠(binary right fold)
( pack op ... op init )
二元右折叠(E op ... op I)展开之后变为 E1 op (... op (EN−1 op (EN op I)))
4、二元左折叠(binary left fold)
( init op ... op pack )
二元左折叠(I op ... op E)展开之后变为 (((I op E1) op E2) op ...) op EN

op代表运算符，在二元折叠中，两个运算符必须相同。

pack代表参数包

init代表初始值

省略号在包的左边就是左折叠
省略号在包的右边就是右折叠

10.
decltype推导规则
decltype(e)（其中e的类型为T）的推导规则有5条：

如果e是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。
如果e是一个函数调用或者仿函数调用(或者表达式），那么decltype(e)推断出的类型是其返回值的类型。
如果e是一个类型为T的左值，则decltype(e)是T&。cv操作符将被保留。
如果e是一个类型为T的将亡值，则decltype(e)是T&&。
除去以上情况，则decltype(e)是T
11.
如果要让数组不衰退成指针类型的话，
现在提倡
template <typename T>
void fun( T& x ) { ... } (也能推断出数组大小)

template <typename T, size_t N>
void fun( T (&x)[N] ) { ... } 
这种写法在"effective modern c++"中已经提到，是多余的。

