结构体对齐准则

先来看四个重要的基本概念：

(1)数据类型自身的对齐值：char型数据自身对齐值为1字节,short型数据为2字节,int /
    float型为4字节,double型为8字节。

(2)结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。

(3)指定对齐值： #pragma pack(value) 时的指定对齐值value。

(4)数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者,即有效对齐值 =min(自身对齐值,当前指定的pack值)
。

基于上面这些值,就可以方便地讨论具体数据结构的成员和其自身的对齐方式。
其中,有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”,即该数据的“存放起始地址 %N =0”。
而数据结构中的数据变量都是按定义的先后顺序存放。
第一个数据变量的起始地址就是数据结构的起始地址。
结构体的成员变量要对齐存放,结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

上面的概念非常便于理解,不过个人还是更喜欢下面的对齐准则。

结构体字节对齐的细节和具体编译器实现相关,但一般而言满足三个准则：

(1)结构体变量的首地址能够被其最宽基本类型成员(有效对齐值)的大小所整除

(2)结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小(有效对齐值)的整数倍,如有需要编译器会在成员之间加上填充字节(internal adding);

(3)结构体的总大小为结构体最宽基本类型成员大小(有效对齐值)的整数倍,如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。

对于以上规则的说明如下:

(1)编译器在给结构体开辟空间时,首先找到结构体中最宽的基本数据类型(有效对齐值),然后寻找内存地址能被该基本数据类型所整除的位置,作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。

(2)为结构体的一个成员开辟空间之前,编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍,若是,则存放本成员,反之,则在本成员和上一个成员之间填充一定的字节,以达到整数倍的要求,也就是将预开辟空间的首地址后移几个字节。

(3)结构体总大小是包括填充字节,最后一个成员满足上面两条以外,还必须满足第三条,否则就必须在最后填充几个字节以达到本条要求。